{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pytest-impacted","text":"<p>Run only the tests that matter. A pytest plugin that uses git diff, AST parsing, and dependency graph analysis to selectively run tests impacted by your code changes.</p> <pre><code>pytest --impacted --impacted-module=my_package     # unstaged changes\npytest --impacted --impacted-module=my_package \\\n       --impacted-git-mode=branch \\\n       --impacted-base-branch=main                 # branch changes vs main\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"Feature Details Fast feedback Only runs tests affected by your changes \u2014 skip the rest Dependency-aware Follows import chains transitively, not just direct file changes No imports at analysis time Filesystem discovery + AST parsing \u2014 no module-level side effects pytest-native Works as a standard pytest plugin with familiar CLI options conftest.py aware Changes to <code>conftest.py</code> automatically impact all tests in scope CI-friendly Standalone <code>impacted-tests</code> CLI for two-stage CI pipelines Helpful errors Validates config early with clear messages and suggestions <p>[!CAUTION] This project is currently in beta. Please report bugs via the Issues tab.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pytest-impacted\n</code></pre> <p>Or with uv:</p> <pre><code>uv add pytest-impacted\n</code></pre> <p>Requires Python 3.11+.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>1. Run tests impacted by uncommitted changes:</p> <pre><code>pytest --impacted --impacted-module=my_package\n</code></pre> <p>2. Run tests impacted by branch changes (vs <code>main</code>):</p> <pre><code>pytest --impacted \\\n       --impacted-module=my_package \\\n       --impacted-git-mode=branch \\\n       --impacted-base-branch=main\n</code></pre> <p>3. Include tests outside the package directory:</p> <pre><code>pytest --impacted \\\n       --impacted-module=my_package \\\n       --impacted-tests-dir=tests\n</code></pre> <p>That's it. Unaffected tests are automatically skipped.</p>"},{"location":"#how-it-works","title":"How It Works","text":"<pre><code>Git diff \u2192 Changed files \u2192 Module resolution \u2192 AST import parsing \u2192 Dependency graph \u2192 Impacted tests\n</code></pre> <ol> <li>Git introspection identifies which files changed (unstaged edits or branch diff)</li> <li>Filesystem discovery maps file paths to Python module names \u2014 without importing anything</li> <li>AST parsing (via astroid) extracts import relationships from source files</li> <li>Dependency graph (via NetworkX) traces transitive dependencies from changed modules to test modules</li> <li>Test filtering skips tests whose modules are not in the impact set</li> </ol> <p>The philosophy is to err on the side of caution: we favor false positives (running a test that didn't need to run) over false negatives (missing a test that should have run).</p>"},{"location":"#strategy-based-architecture","title":"Strategy-Based Architecture","text":"<p>Impact analysis is pluggable via a strategy pattern. The default pipeline combines two strategies:</p> Strategy What it does ASTImpactStrategy Traces transitive import dependencies through the dependency graph PytestImpactStrategy Extends AST analysis with pytest-specific knowledge \u2014 when a <code>conftest.py</code> file changes, all tests in its directory and subdirectories are marked as impacted <p>Both strategies are combined via <code>CompositeImpactStrategy</code>, which deduplicates and merges their results. This is important because <code>conftest.py</code> files are implicitly loaded by pytest at runtime and are not visible through normal import analysis.</p> <p>You can also supply a custom strategy via the <code>get_impacted_tests()</code> API:</p> <pre><code>from pytest_impacted.api import get_impacted_tests\nfrom pytest_impacted.strategies import ImpactStrategy\n\nclass MyCustomStrategy(ImpactStrategy):\n    def find_impacted_tests(self, changed_files, impacted_modules, ns_module, **kwargs):\n        # your logic here\n        ...\n\nimpacted = get_impacted_tests(\n    impacted_git_mode=\"branch\",\n    impacted_base_branch=\"main\",\n    root_dir=Path(\".\"),\n    ns_module=\"my_package\",\n    strategy=MyCustomStrategy(),\n)\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#git-modes","title":"Git Modes","text":"Mode Flag What it compares unstaged (default) <code>--impacted-git-mode=unstaged</code> Working directory changes + untracked files branch <code>--impacted-git-mode=branch</code> All commits on current branch vs base branch <p>The <code>--impacted-base-branch</code> flag accepts any valid git ref, including expressions like <code>HEAD~4</code>.</p>"},{"location":"#external-tests-directory","title":"External Tests Directory","text":"<p>When your tests live outside the namespace package (a common layout), use <code>--impacted-tests-dir</code> so the dependency graph includes them:</p> <pre><code>pytest --impacted \\\n       --impacted-module=my_package \\\n       --impacted-tests-dir=tests\n</code></pre>"},{"location":"#ci-integration","title":"CI Integration","text":"<p>For CI pipelines where git access and test execution happen in separate stages, use the <code>impacted-tests</code> CLI to generate the test file list:</p> <pre><code># Stage 1: identify impacted tests\nimpacted-tests --module=my_package --git-mode=branch --base-branch=main &gt; impacted_tests.txt\n\n# Stage 2: run only those tests\npytest $(cat impacted_tests.txt)\n</code></pre>"},{"location":"#configuration-via-pyprojecttoml","title":"Configuration via <code>pyproject.toml</code>","text":"<p>All CLI options can be set as defaults in your <code>pyproject.toml</code> (or <code>pytest.ini</code>):</p> <pre><code>[tool.pytest.ini_options]\nimpacted = true\nimpacted_module = \"my_package\"\nimpacted_git_mode = \"branch\"\nimpacted_base_branch = \"main\"\nimpacted_tests_dir = \"tests\"\n</code></pre> <p>CLI flags override these defaults.</p>"},{"location":"#all-options","title":"All Options","text":"Option Default Description <code>--impacted</code> <code>false</code> Enable the plugin <code>--impacted-module</code> (required) Top-level Python package to analyze <code>--impacted-git-mode</code> <code>unstaged</code> Git comparison mode: <code>unstaged</code> or <code>branch</code> <code>--impacted-base-branch</code> (required for branch mode) Base branch/ref for branch-mode comparison <code>--impacted-tests-dir</code> <code>None</code> Directory containing tests outside the package"},{"location":"#alternatives","title":"Alternatives","text":"Project Notes pytest-testmon Most popular option. Uses coverage-based granular change tracking. More precise but heavier; may conflict with other plugins. pytest-picked Runs tests from directly modified files only \u2014 no transitive dependency analysis. pytest-affected Appears unmaintained, no source repository."},{"location":"#development","title":"Development","text":"<p>This project uses uv for dependency management.</p> <pre><code># Setup\nuv sync --all-extras --dev\n\n# Run tests\nuv run python -m pytest\n\n# Run tests with coverage\nuv run python -m pytest --cov=pytest_impacted --cov-branch tests\n\n# Lint + format + type check\npre-commit run --all-files\n</code></pre>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"usage/","title":"Usage Guide","text":""},{"location":"usage/#basic-usage","title":"Basic Usage","text":"<p>Activate the plugin by passing the <code>--impacted</code> flag along with <code>--impacted-module</code> to pytest:</p> <pre><code>pytest --impacted --impacted-module=my_package\n</code></pre> <p>This runs only the tests impacted by files with unstaged modifications in your current git repository.</p> <p>Note</p> <p>The <code>--impacted-module</code> value must be a valid Python package name (underscores, not hyphens). If you accidentally use hyphens, the plugin will suggest the corrected name.</p>"},{"location":"usage/#git-modes","title":"Git Modes","text":""},{"location":"usage/#unstaged-mode-default","title":"Unstaged Mode (default)","text":"<p>Compares your working directory changes (including untracked files) against the current HEAD:</p> <pre><code>pytest --impacted --impacted-module=my_package --impacted-git-mode=unstaged\n</code></pre>"},{"location":"usage/#branch-mode","title":"Branch Mode","text":"<p>Compares all commits on your current branch against a base branch:</p> <pre><code>pytest --impacted \\\n       --impacted-module=my_package \\\n       --impacted-git-mode=branch \\\n       --impacted-base-branch=main\n</code></pre> <p>The <code>--impacted-base-branch</code> flag accepts any valid git ref, including expressions like <code>HEAD~4</code>.</p>"},{"location":"usage/#external-tests-directory","title":"External Tests Directory","text":"<p>When your tests live outside the namespace package (a common project layout), use <code>--impacted-tests-dir</code> so the dependency graph includes them:</p> <pre><code>pytest --impacted \\\n       --impacted-module=my_package \\\n       --impacted-tests-dir=tests\n</code></pre> <p>The tests directory must be importable as a Python package (i.e., contain an <code>__init__.py</code> or be otherwise discoverable).</p>"},{"location":"usage/#impact-analysis-strategies","title":"Impact Analysis Strategies","text":"<p>The plugin uses a modular, strategy-based architecture to determine which tests are affected by code changes. Strategies are composable \u2014 the default pipeline combines two built-in strategies.</p>"},{"location":"usage/#astimpactstrategy","title":"ASTImpactStrategy","text":"<p>The core strategy. It uses static analysis to:</p> <ol> <li>Discover all submodules via filesystem scanning (no imports executed)</li> <li>Parse each source file's AST to extract import relationships</li> <li>Build a dependency graph with NetworkX</li> <li>Trace transitive dependencies from changed modules to test modules</li> </ol>"},{"location":"usage/#pytestimpactstrategy","title":"PytestImpactStrategy","text":"<p>Extends the AST analysis with pytest-specific dependency detection:</p> <ul> <li><code>conftest.py</code> handling: When a <code>conftest.py</code> file is modified, all tests in the same directory and subdirectories are considered impacted. This is critical because <code>conftest.py</code> files are implicitly loaded by pytest at runtime and are not visible through normal import analysis.</li> <li>Designed to be extended with additional pytest-specific heuristics in the future.</li> </ul>"},{"location":"usage/#compositeimpactstrategy","title":"CompositeImpactStrategy","text":"<p>Combines multiple strategies, deduplicating and sorting results. The default composition is:</p> <pre><code>CompositeImpactStrategy([\n    ASTImpactStrategy(),\n    PytestImpactStrategy(),\n])\n</code></pre>"},{"location":"usage/#custom-strategies","title":"Custom Strategies","text":"<p>You can implement your own strategy by subclassing <code>ImpactStrategy</code> and passing it to the <code>get_impacted_tests()</code> API:</p> <pre><code>from pathlib import Path\nfrom pytest_impacted.api import get_impacted_tests\nfrom pytest_impacted.strategies import ImpactStrategy\n\nclass MyCustomStrategy(ImpactStrategy):\n    def find_impacted_tests(self, changed_files, impacted_modules, ns_module, **kwargs):\n        # your logic here\n        ...\n\nimpacted = get_impacted_tests(\n    impacted_git_mode=\"branch\",\n    impacted_base_branch=\"main\",\n    root_dir=Path(\".\"),\n    ns_module=\"my_package\",\n    strategy=MyCustomStrategy(),\n)\n</code></pre>"},{"location":"usage/#ci-integration","title":"CI Integration","text":"<p>For CI pipelines where git analysis and test execution happen in separate stages, use the standalone <code>impacted-tests</code> CLI:</p> <pre><code># Stage 1: identify impacted tests\nimpacted-tests --module=my_package --git-mode=branch --base-branch=main &gt; impacted_tests.txt\n\n# Stage 2: run only those tests\npytest $(cat impacted_tests.txt)\n</code></pre>"},{"location":"usage/#configuration-via-pyprojecttoml","title":"Configuration via <code>pyproject.toml</code>","text":"<p>All CLI options can be set as defaults in your <code>pyproject.toml</code> (or <code>pytest.ini</code>):</p> <pre><code>[tool.pytest.ini_options]\nimpacted = true\nimpacted_module = \"my_package\"\nimpacted_git_mode = \"branch\"\nimpacted_base_branch = \"main\"\nimpacted_tests_dir = \"tests\"\n</code></pre> <p>CLI flags override these defaults.</p>"},{"location":"usage/#input-validation","title":"Input Validation","text":"<p>The plugin validates configuration early and provides helpful error messages:</p> Scenario What happens <code>--impacted-module=my-package</code> (hyphens) Suggests <code>my_package</code> if it exists <code>--impacted-module=nonexistent</code> Clear error with instructions to check the package name and working directory <code>--impacted-tests-dir=bad_path</code> Error indicating the directory doesn't exist <code>--impacted-tests-dir=exists_but_not_importable</code> Error explaining the directory needs to be an importable Python package <code>--impacted-base-branch=no_such_branch</code> Error listing available git refs"},{"location":"usage/#all-options","title":"All Options","text":"Option Default Description <code>--impacted</code> <code>false</code> Enable the plugin <code>--impacted-module</code> (required) Top-level Python package to analyze <code>--impacted-git-mode</code> <code>unstaged</code> Git comparison mode: <code>unstaged</code> or <code>branch</code> <code>--impacted-base-branch</code> (required for branch mode) Base branch/ref for branch-mode comparison <code>--impacted-tests-dir</code> <code>None</code> Directory containing tests outside the package"},{"location":"usage/#how-it-works-pipeline","title":"How It Works (Pipeline)","text":"<pre><code>graph LR\n    A[Git diff] --&gt; B[Changed files]\n    B --&gt; C[Module resolution]\n    C --&gt; D[AST import parsing]\n    D --&gt; E[Dependency graph]\n    E --&gt; F[Impacted tests]</code></pre> <ol> <li>Git introspection identifies which files changed (unstaged edits or branch diff)</li> <li>Filesystem discovery maps file paths to Python module names \u2014 without importing anything</li> <li>AST parsing (via astroid) extracts import relationships from source files</li> <li>Dependency graph (via NetworkX) traces transitive dependencies from changed modules to test modules</li> <li>Test filtering skips tests whose modules are not in the impact set</li> </ol> <p>The philosophy is to err on the side of caution: false positives (running a test that didn't need to run) are preferred over false negatives (missing a test that should have run).</p>"}]}